// Generated by CoffeeScript 1.4.0
(function() {
  var EventEmitter, Service, async, fs, handlebars, htmlToText, mailer, markdown, mockquery, path, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  handlebars = require('handlebars');

  mailer = require('nodemailer');

  markdown = require('marked');

  htmlToText = require('html-to-text');

  EventEmitter = require('events').EventEmitter;

  async = require('async');

  _ = require('underscore');

  fs = require('./fs');

  path = require('path');

  mockquery = require('mockquery');

  Service = (function() {

    Service.transports = {};

    Service.templates = {};

    Service.loadTemplates = function(rootPath, cb) {
      var asyncHelper, makeTask;
      makeTask = function(filePath) {
        return function(cb) {
          return fs.readFile(path.join(rootPath, filePath), 'utf8', function(err, data) {
            var ext, templateName;
            if (err) {
              return cb(err);
            } else {
              try {
                ext = path.extname(filePath);
                templateName = path.join(path.dirname(filePath), path.basename(filePath, ext));
                if (ext === '.md') {
                  data = markdown(data);
                }
                handlebars.registerPartial(templateName, data);
                Service.templates[templateName] = handlebars.compile(data);
                return cb(null, templateName);
              } catch (e) {
                return cb(e);
              }
            }
          });
        };
      };
      asyncHelper = function(files) {
        var file, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          _results.push(makeTask(file));
        }
        return _results;
      };
      return fs.loadPaths(rootPath, {
        filter: ['.md', '.hbs']
      }, function(err, files) {
        if (err) {
          return cb(err);
        } else {
          return async.parallel(asyncHelper(files), cb);
        }
      });
    };

    Service.make = function(config) {
      var name;
      if (!config.hasOwnProperty('name')) {
        throw new Error("Service.make:config_must_have_name");
      }
      name = config.name;
      if (this.transports.hasOwnProperty(name)) {
        throw new Error("Service.make:transport_already_exists: " + name);
      }
      this.transports[name] = new this(config);
      return this.transports[name];
    };

    function Service(config) {
      this.config = config;
      this.close = __bind(this.close, this);

      process.on('exit', this.close);
    }

    Service.prototype.transform = function(args, data) {
      var $, html, htmlSource, layoutTemplate, template, testTitle, text;
      htmlSource = args.type === 'markdown' ? markdown(args.template) : args.template;
      template = this.constructor.templates.hasOwnProperty(htmlSource) ? this.constructor.templates[htmlSource] : handlebars.compile(htmlSource);
      html = template(data);
      if (!args.hasOwnProperty('layout') || args['layout'] !== false) {
        layoutTemplate = this.constructor.templates[typeof args.layout === 'string' ? args.layout : 'layout'];
        html = layoutTemplate({
          body: html
        });
      }
      text = htmlToText.fromString(html, {
        wordwrap: 72
      });
      $ = mockquery.load(html);
      testTitle = $('title');
      if (testTitle.length > 0) {
        return {
          html: html,
          text: text,
          title: testTitle.html()
        };
      } else {
        return {
          html: html,
          text: text
        };
      }
    };

    Service.prototype.close = function() {
      if (this.transport) {
        this.transport.close();
        return delete this.transport;
      }
    };

    Service.prototype.sendOne = function(args, data, cb) {
      var trans;
      try {
        if (!this.transport) {
          this.init();
        }
        trans = this.transform(args, data);
        args = _.extend({}, args, trans);
        if (data.email) {
          args.to = data.email;
        }
        if (!args.to) {
          throw new Error("Service.send:to_address_is_missing");
        }
        console.log('Service.sendOne', args.to, args.from);
        return this.transport.sendMail(args, function(err, res) {
          if (err) {
            return cb(err);
          } else {
            return cb(null, res);
          }
        });
      } catch (e) {
        return cb(e);
      }
    };

    Service.prototype.send = function(args, data, cb) {
      var helper,
        _this = this;
      if (data instanceof Array) {
        helper = function(item, next) {
          return _this.sendOne(args, item, next);
        };
        return async.map(data, helper, function(err, reses) {
          if (err) {
            return cb(err);
          } else {
            return cb(null, reses);
          }
        });
      } else {
        return this.sendOne(args, data, cb);
      }
    };

    Service.prototype.init = function() {
      return this.transport = mailer.createTransport(this.config.type || 'SMTP', this.config);
    };

    return Service;

  })();

  module.exports = Service;

}).call(this);
